/* runs the algorithm on mdp given by a transition file and 1 or 2 reward files
 * the formats are described here: 
        * https://www.prismmodelchecker.org/manual/Appendices/ExplicitModelFiles
        * the only difference is that the parser simply ignores the first line
        * that is not a comment, in the original prism format this line is used
        * to pass counts of states and actions, but i didn't use it ( hence in
        * the testing files some files simply have a header text at that place )
        *
 * the underlying brtdp solver is called with the passed discount parameters 
 * and samples trajectories from the given starting state of the mdp
 * precision gives the stopping condition, i.e how close w.r.t to hausdorff
 * distance the difference of the starting bounds has to be before we terminate
 * the computation
 *
 * both pareto curves of the starting state are then output to text files
 * starting_lower.txt, starting_upper.txt in the same directory as ( both their
 * vertices and facets respectivelly )
 */

void test_brtdp( const std::string &transition_file,
                 const std::vector< std::string > &reward_files,
                 std::vector< double > discount_params,
                 size_t starting_state=0,
                 double precision=0.1 ) {

    // construct parser object
    PrismParser parser;

    // parse the provided files
    auto mdp = parser.parse_model( transition_file,
                                   reward_files,
                                   starting_state );

    // construct a wrapper object around the mdp ( initializes the object
    // bounds, and the solver uses it to interact with the model )
    EnvironmentWrapper< size_t, size_t, std::vector<double>, double> env_wrap( &mdp );

    // construct the solver object using the wrapper and discount parameters
    ExplorationSettings< double > basic;
    basic.discount_params = discount_params;
    basic.precision = precision;

    BRTDPSolver brtdp( std::move( env_wrap ), basic );

    // solve up to given precision
    auto start_bound = brtdp.solve();

    // output the lower/upper bounds of the starting state
    std::cout << start_bound;
}

void treasure_check(){
    DeepSeaTreasure dst, dst_convex;

    dst.from_file( "../benchmarks/sea_treasure1.txt" );
    dst_convex.from_file( "../benchmarks/sea_treasure_convex.txt" );

    EnvironmentWrapper< TreasureState, Direction, std::vector<double>, double > env_wrap( &dst );
    EnvironmentWrapper< TreasureState, Direction, std::vector<double>, double > env_wrap_chvi( &dst_convex );

    ExplorationSettings< double > config;
    config.max_episodes = 1000;
    config.discount_params = { 0.95, 0.95 };
    config.lower_bound_init = { -1000, -1000 };
    config.upper_bound_init = { 150, 0 };
    config.lower_bound_init_term = { -1000, -1000 };
    config.upper_bound_init_term = { 150, 0 };

    config.trace = true;
    BRTDPSolver brtdp( std::move( env_wrap ), config );

    CHVIExactSolver chvi(std::move( env_wrap_chvi ), config );
    chvi.solve();


    auto start_bound = brtdp.solve();
    std::cout << start_bound;

    brtdp.load_environment( dst_convex );
    start_bound = brtdp.solve();
    std::cout << start_bound;
}


void resource_check(){

    ResourceGathering env( 5, 5, // height & width
                           Coordinates( 4, 2 ), // starting pos
                           { Coordinates( 0, 2 ) }, // gold
                           { Coordinates( 1, 4 ) }, // gems 
                           {  } // attackers
                           ); 
    
    EnvironmentWrapper< ResourceState, Direction, std::vector<double>, double > env_wrap( &env );
    EnvironmentWrapper< ResourceState, Direction, std::vector<double>, double> env_wrap2( &env );

    ExplorationSettings< double > config;
    config.discount_params = { 0.9, 0.9 };
    config.lower_bound_init = {};
    config.upper_bound_init = {};
    config.precision = 0.1;
    config.lower_bound_init_term = {};
    config.upper_bound_init_term = {};
    BRTDPSolver brtdp( std::move( env_wrap ), config );

    CHVIExactSolver chvi( std::move( env_wrap2 ), config );
    auto start_bound2 = chvi.solve();
    std::cout << start_bound2;

    // solve up to given precision
    auto start_bound = brtdp.solve();

    // output the lower/upper bounds of the starting state
    std::cout << start_bound;

}

int main(){

    
    treasure_check();
    resource_check();

    PRNG gen;
    std::set< Coordinates > randpits;
    for ( int i = 0; i < 25; ++i ) {
       randpits.insert( Coordinates( gen.rand_int( 1, 25), gen.rand_int( 1, 25 ) ) );
    }

    for ( auto &x : randpits ) {
        std::cout << x << "\n";
    }


    FrozenLake lake, lake2( 25, 25, randpits, 0.3 );
    lake.set_hyperparams( 0.3 );

    EnvironmentWrapper< Coordinates, Direction, std::vector< double >, double > envw( &lake );
    EnvironmentWrapper< Coordinates, Direction, std::vector< double >, double > envw2( &lake2 );

    ExplorationSettings< double > config;


    Racetrack race;
    race.from_file( "../benchmarks/barto-big.track" );
    EnvironmentWrapper< VehicleState, std::pair< int, int >, std::vector< double >, double > env_race( &race );

    config.action_heuristic = ActionSelectionHeuristic::Pareto;
    config.min_trajectory = 1000;
    config.max_trajectory = 1000;
    config.max_episodes = 1000;
    config.trace = false;
    config.precision = 0.001;
    config.filename = "laketest";
    config.lower_bound_init = { -100, -100 };
    config.upper_bound_init = { 0, 0 };
    config.lower_bound_init_term = { 0, 0 };
    config.upper_bound_init_term = { 0, 0 };
    config.discount_params =  { 0.95, 0.95 };

    BRTDPSolver brtdp( std::move( envw ), config );
    brtdp.solve();

    return 0;

    CHVIExactSolver chvi( std::move( envw ), config );
    auto res = chvi.solve();

    config.filename = "racetest";

    BRTDPSolver brtdp_race( std::move( env_race ), config );
    brtdp_race.load_environment( race );
    brtdp_race.solve();


    /*
    Racetrack race;
    race.from_file("../benchmarks/barto-big.track");
    EnvironmentWrapper< VehicleState, std::pair< int, int >, std::vector< double >, double > racew( &race );

    config.lower_bound_init = { -1000, -10000  };
    config.precision = 0.01;
    config.trace = true;
    config.upper_bound_init = { 0,  1 };
    config.action_heuristic = ActionSelectionHeuristic::Uniform;

    BRTDPSolver solver( std::move( racew ), config );
    solver.solve();
    */

    return 0;
}

